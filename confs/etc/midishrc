# Load
dmmctx {}
dclktx  {}
# DISPOSITIVOS
#import "/root/output.mid"
#dnew 0 "14:1" rw

dnew 1 "FLUID Synth (fluidsynth)" wo

# dnew 2 "ZynAddSubFX" wo 
# dnew 2 "yoshimi" wo
# WORK ARROUND
# MIDISH NO SE COMUNICA DIRECTAMENTE CON YOSHSIMI, hay que usar a2j_bridje
dnew 2 "a2j_bridge" wo

# INPUTS
dnew 3 "Origin49" ro

# inew from_kb {3 0} 
# DUMP & THRU 
# dnew 14 "14:0" rw
# inew from_thru {14 0} 
# onew to_thru {14 0} 

dnew 4 "alsa_midi:Midi Through Port-0 (in)" ro
dclkrx 4;

dnew 15 "aseqdump" wo

## FILTERS


proc teclado{
  fnew kb_analog 
  # Drop Pitch Bend
  # del teclado por que anda mal en el teclado
  fmap { note { 3 0 } } { note { 1 0 } }
  # fmap { note { 3 0..15 }   } { note { 2 0..15 }    }
  # fmap { ctl  { 3 0..15 } 1 } { ctl  { 2 0..15 } 1  }
  # fmap { ctl  { 3 0..15 } 7 } { ctl  { 2 0..15 } 7  }
  # fmap { ctl  { 3 0..15 } 8 } { ctl  { 2 0..15 } 71 }
  # fmap { ctl  { 3 0..15 } 9 } { ctl  { 2 0..15 } 74 }
  # fmap { ctl  { 3 0..15 } 10 } { ctl  { 2 0..15 } 75 }
  # fmap { ctl  { 3 0..15 } 11 } { ctl  { 2 0..15 } 76 }
  # fmap { ctl  { 3 0..15 } 12 } { ctl  { 2 0..15 } 77 }
  # fmap { ctl  { 3 0..15 } 13 } { ctl  { 2 0..15 } 78 }
}

# WARNING: si se usa map "any" pisa map "note" previo
#fmap { any { 3 0 } } { any { 15 0 } }
#fmap { note { 3 0..15 } } { note { 15 0..15 } }
#fmap { ctl { 3 0 } } { ctl { 15 0 } }

# ojo rango de canales pisa mapeos individuales
# fmap { any {  0 0..15} } { any { 15 0..15 } }
# fmap { any { 14 0..15} } { any { 15 0..15 } }

metrocf { non { 1 9 } 31 127 } { non { 1 9 } 31 110 }
m on
t 60
teclado
i


#in Midish you add the ALSA port of the bridge. For a2jmidi_bridge this is:
#dnew 6 "j2a_bridge" ro;
#Then you choose that device - six in the above example - as the master clock:
#dclkrx 6;

#I put this in my .midishrc as the procedure add_ext_clk:
proc add_ext_clk {
   #dnew 6 "j2a_bridge" ro;
   #dclkrx 6;
}

proc cargar track{
  import $track 
  g 0                # go to the beginning
  sel [mend]         # select to the end
  for t in [tlist] { # for each track:
    ct $t            # make it the current track
    # tevmap {any 0 } {any 1}  # set all events device 0 -> 1
    tevmap { any { 0 0..9 } } { any { 1 0..9 } }  
    tevmap { any { 0 10..15  } } { any { 2 10..15  } }  
    tevmap { any { 0 0..15 } } { any { 15 0..15 } }  
  }
  teclado
  metrocf {non { 1 9 } 31 127} {non { 1 9} 31 110 }
  # t 60
  # p
}


# dmmctx { devnum1 devnum2 ... }
# Configure the given devices to transmit MMC start, stop and relocate messages.
# Useful to control MMC-capable audio applications from midish. By default,
# devices transmit MMC. 
# 
# dclktx { devnum1 devnum2 ... }
# Configure the given devices to transmit MIDI clock information (MIDI ticks,
# MIDI start and MIDI stop events). Useful to synchronize an external sequencer
# to midish. 
# 
# dclkrx devnum
# set device number ``devnum'' to be the master MIDI clock source. It will give
# midish MIDI ticks, MIDI start and MIDI stop events. This useful to synchronize
# midish to an external sequencer. If ``devnum'' is ``nil'', then the internal
# clock will be used and midish will act as master device. 

# YOSHIMI CC
# 1  Pitch bend
# 2  Modullation wheel (Controller number 1)
# 3  Volume (no. 7)
# 4  Pan (no. 10)
# 5  Expression (no. 11)
# 6  Sustain (no. 64)
# 7  Portamento On/Off (no. 65)
# 8  Filter Q (no. 71)
# 9  Filter cutoff (no. 74)
# 10 All sound off (no. 120)
# 11 Reset all controlers (no. 121)

 
# cf file_fluid
# 12 All notes off (no. 123) 

